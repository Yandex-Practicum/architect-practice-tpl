# Технический проект "Сервис отправки оповещений"

> Это фрагмент Технического проекта, который нужно заполнить в рамках практического задания темы "Технический проект".
---

## Текущая архитектура

В текущей архитектуре у нас есть мобильное приложение, которое общается с компонентом "Controller", а он в свою очередь делает запросы к "Foo" и "Bar".

![alt text](static/current_arch.svg)


## Целевая архитектура

### Диаграмма контекста (C1):
![C1](static/c1.svg)

Предполагается, что любой из существующих компонентов может отправить оповещение пользователю. При этом существующие каналы связи и предпочтения по их использованию известны системе оповещений, компоненты остальной системы знать это не должны.

### Диаграмма контейнеров (C2):
![C2](static/c2.svg)

В результате анализа представленного задания и пояснений из README.md были определены следующие процессы:
- Основные процессы:
    - Процесс принятия запроса на формирование рассылки.
    - Процесс сохранения параметров настройки по каждому каналу связи для рассылки уведомлений.
    - Процесс сохранения информации об отправленных запросах.
    - Процесс рассылки одиночного оповещения.
    - Процесс рассылки оповещений по заданному регламенту (с определенным периодом).
    - Процесс мультиплексирования оповещений и управления рассылкой.

- Процессы управления:
    - Процесс обслуживания входного соединения и обработки нештатных ситуаций (сетевые ошибки, задержки и т.п.).

- Процессы поддержки:
    - Процесс стыковки с сервисом отправки SMS.
    - Процесс стыковки с сервисом отправки EMail.
    - Процесс стыковки с сервисом отправки Push-уведомлений.
    - Процесс централизованного сбора логов.
    - Процесс централизованного сбора метрик.
    - Процесс централизованного сбора данных трассировки с компонент системы, которые стыкуются с внешними системами.

Определены следующие виды данных:
- Бизнес-данные:    
    - Настройки по каждому каналу связи для рассылки уведомлений.
    - Параметры рассылки уведомлений (регламентные рассылки).
    - Данные о уведомлениях, которые были отправлены (возможно этот пункт стоит отнести к "отчетным и аналитическим данным").

- Отчетные и аналитические данные.
    - Логи с компонент системы.
    - Метрики с компонент системы.
    - Результаты трассировки запросов.

Данная архитектура построена на основе следующих ADR:
| ID | Дата | Статус | Участники         | Решения             |
| --- | --- | --- |-------------------|---------------------|
| ADR-001 | 2023.10.07 | Предложено | Абдрахманов Марат |  |
| ADR-002 | 2023.10.07 | Предложено | Абдрахманов Марат |  |
| ADR-003 | 2023.10.07 | Предложено | Абдрахманов Марат |  |
| ADR-004 | 2023.10.07 | Предложено | Абдрахманов Марат |  |
| ADR-005 | 2023.10.07 | Предложено | Абдрахманов Марат |  |
| ADR-006 | 2023.10.07 | Предложено | Абдрахманов Марат |  |

Для защиты от нецелевого доступа к системе предусмотреть:
- реализацию функций аутентификации и авторизации;
- аутентификацию внешних пользователей проводить на уровне API Gateway;
- логины/пароли хранить в БД "Параметры отправителей и регламентных рассылок";
- пароли не хранить в открытом виде, только в виде хешей;
- авторизацию действий производить на уровне API Gateway.

В рамках данного решения были использованы следующие паттерны:
- Subroutine, в виде которого представлены:
    - API Gateway - входной шлюз в систему;
    - Notify Service - сервис обработки уведомлений;
    - Multiplexer & Sender Service - сервис мультиплексирования и отправки уведомлений;
    - SMS Gateway - шлюз для работы с сервисом отправки SMS;
    - Push-notify Gateway - шлюз для работы с сервисом отправки Push-уведомлений;
    - EMail Gateway - шлюз для работы с сервисом отправки EMail'ов;
    - Tracing Service - сервис для сбора результатов трассировки;
    - Metrics Service - сервис для сбора метрик;
    - Logging Service - сервис для сбора логов.
- Storage, в виде которого представлены:
    - БД для хранения параметров отправителей и регламентных рассылок;
    - БД для хранения истории рассылок;
    - Trace-хранилище;
    - Хранилище для логов;
    - Хранилище для метрик.
- Queue, в виде которой представлен брокер для реализации асинхронного взаимодействия между API Gateway, Notify Service и Multiplexer & Sender Service.
- Proxy, в виде которого представлены:
    - Proxy In - прокси на входе в систему;
    - Proxy Out - прокси на выходе из системы.

Дополнительно нужно уточнить требования по времени хранения информации об отправленных уведомлениях.

В результате анализа представленных ADR были сделаны следующие заключения (гипотезы):
- Если требуемое время хранения данных будет достаточно велико и, при этом, количество данных в "БД хранения рассылок" станет слишком большим, то можно сделать шардирование БД.
- Если нет жестких требований к хранению истории уведомлений, то необходимо предусмотреть периодическое удаление старых данных из "БД хранения рассылок".
- Если необходимо будет шардирование "БД хранения рассылок", то раздельное хранение настроек каналов и пользовательских данных от информации о рассылках упростит этот процесс.
- Если нагрузка на рассылку сильно возрастет, то можно сделать несколько экземпляров API Gateway, а перед ними поставить балансировщик.
- Если будут просадки по производительности, то сервисы трассировки и сбора метрик помогу в выяснения причины.

В текущем решении не до конца проработан вопрос о том, что делать если уведомление не было отправлено. Несколько вариантов решения этого вопроса:
- Контроль отправки осуществляет Multiplexer & Sender Service, если отправка не удалась, то он синхронно об этом уведомляет Notify Service, а тот в свою очередь делает запись в БД.
- Контроль отправки осуществляет Multiplexer & Sender Service, если отправка не удалась, то делает запись в Kafka в топик send_error. Этот топик слушает Notify Service, если получает соответствующее сообщение, то делает запись в БД.
- Контроль отправки осуществляет Multiplexer & Sender Service, если отправка не удалась, то изменяет значение связанной с этим событием метрики. Компонент сбора метрик реагирует на эту метрику в соответствии с заданным регламентом.

### Диаграмма компонент (C3):
Для детального представления внутреннего устройства контейнеров через компоненты и их связи построим несколько диаграмм компонентов.

Диаграмма компонентов API Gateway, Брокера и Notify Service:

![C3](static/c3_1.svg)

Диаграмма компонент построена на основе следующих ADR:
| ID | Дата | Статус | Участники         | Решения             |
| --- | --- | --- |-------------------|---------------------|
| ADR-3001 | 2023.10.08 | Предложено | Абдрахманов Марат |  |

Диаграмма компонентов Multiplexer & Sender Service, SMS Gateway, Push-notify Gateway, EMail Gateway:

![C3](static/c3_2.svg)

Диаграмма компонент построена на основе следующих ADR:
| ID | Дата | Статус | Участники         | Решения             |
| --- | --- | --- |-------------------|---------------------|
| ADR-3002 | 2023.10.08 | Предложено | Абдрахманов Марат |  |

Отдельная диаграмма компонентов для трассировки, сборки метрик и сохранения логов не приводится, т.к. они строятся на базе стандартных решений. Для централизованного сбора и хранения логов будет использоваться Graylog, который для работы дополнительно требует развернутый ElasticSearch, в качестве хранилища используется MongoDB (https://graylog.org/), для работы с метриками выберем Prometheus (https://prometheus.io/), а для хранения трейсов - Jager (https://www.jaegertracing.io/).

В рамках данного решения были использованы следующие реализации паттернов:
- Subroutine:
    - API Gateway - микросервис, у которого есть "ручки" для приема настроек и заданий на рассылку уведомлений, он валидирует запрос и отправляет его в брокер;
    - Notify Service - микросервис, считывающий из брокера результаты работы API Gateway и отправляющий в брокер задания на отправку. Состоит из двух подсистем: первая (New notify service processor) принимает данные из брокера (от API Gateway), обрабатывает их, фиксирует в БД, и, при необходимости, уведомляет вторую подсистему о том, что нужно сделать отправку уведомлений. Вторая (Notify sender service) принимает запросы на отправку уведомлений от первой, планирует отправку, считывает настройки из соответствующей БД и фиксирует момент отправки записью в БД истории уведомлений. Для связи первой и второй подсистем можно использовать паттерн Наблюдатель (Observer).
    - Multiplexer & Sender Service - микросервис, считывающий задания на отправку из брокера, определяющий какого типа это задание (точечное или групповое) и с каким шлюзом нужно работать, и отправляющий в целевой шлюз запрос на отправку по gRPC.
    - SMS Gateway, Push-notify Gateway, EMail Gateway - микросервисы принимающие по gRPC команду на отправку уведомлений и реализующие, непосредственно, саму отправку через внешние сервисы.
    - Tracing Service - Jager;
    - Metrics Service - Prometeus;
    - Logging Service - Graylog.
- Storage:
    - БД для хранения параметров отправителей и регламентных рассылок и БД для хранения истории рассылок реализуются на PostgreSQL;    
    - Хранилище для логов - MongoDB;
    - Хранилище для метрик - спец. хранилище для Prometeus.
    - Хранилище для метрик - спец. хранилище для Jager.
- Queue:
    - Kafka.

Для реализации микросервисов можно использовать платформу .NET, язык: C#. Фреймворк для разработки микросервисов: ASP.NET. Доступ к данным можно организовать через Entity Framework либо Dapper. Для работы с Kafka: Confluent.Kafka. Для ведения логов: Serilog. OpenTelemetry для трассировки и prometheus-net для метрик. Аутентификацию и авторизацию можно реализовать на ASP.NET Identity.

### Критерии оценки прототипа

Для оценки прототипа можно ориентироваться на следующие критерии:
- **Соответствие требованиям.** Прототип должен реализовывать прием заданий и отправку следующих видов запросов:
    - отправка разового одиночного уведомления по заданному каналу;
    - отправка разового группового уведомления;
    - отправка регламентного (периодический, отложенный) одиночного уведомления по заданному каналу;
    - отправка регламентного (периодический, отложенный) группового уведомления.
- **Удовлетворение пользовательских потребностей.** В качестве "пользователей системы" выступают внешние, по отношению к нашей, системы. Т.к. в задании нет требований к тому, как стыковаться с нашей системой, было принято решение предоставить возможность работы с сервисом через REST. По идее, вопрос способа стыковки нужно уточнить заранее, до реализации прототипа. Также, в процессе оценки прототипа, у пользователей могут появяться новые потребности, например, в получении статистики по отправкам уведомлений (отправлено, не отправлено, ошибки и т.п.), или в возможности стыковки с системой по gRPC и т.д.
- **Легкость использования.** Оценить реализацию REST в части структуры хендлеров и способа передачи параметров: через сам запрос, заголовоки, тело запроса, удобно ли это.
- **Производительность.** Оценить насколько быстро прототип отвечает на запросы от сторонних систем. Также можно оценить время между моментом подачи запроса на разовую отправку уведомления (одиночного и группового) и времени, когда сервис отправляет задания внешним системам, которые непосредственно эту отправку реализуют. Дополнительно можно произвести оценку времени между отправкой уведомления и временем, когда это уведомление фактически пришло. Так можно выявить какую задержку вносят внешние системы, и, если она слишком большая, подумать об альтернативных вариантах.
- **Надежность.** Для оценки надежности можно провести интеграционное тестирование с проверкой всех сценариев работы. Приложение не должно аварийно завершаться, зависать и т.п. в рамках данного тестирования. Также стоит провести нагрузочное тестирование, и проверить стабильность непрерывной работы системы в течение длительного интервала времени (дни, недели - в зависимости от времени, которое есть на оценку прототипа).
- **Функциональность.** Проверка функциональности также может быть проведена посредством интеграционного тестирования, но в данном случае необходимо проверить, что система выдает ожидаемые ответы на запросы и выполняет действия, которые от нее требуются (отправка уведомлений, запись в базы данных соответствующей запросу информации и т.п.). Если проверка каких-то аспектов системы не поддается автоматизации, то проверить функционал вручную по заранее составленному тест-плану.
- **Обратная связь и участие пользователей.** В рамках оценки по данному критерию стоит обратиться к командам, отвечающим за системы, которые будут использовать нашу для отправки уведомлений и предложить им поработать с готовым прототипом. После этого собрать от них обратную связь в части удобства работы с системой, производительности, удовлетворения их потребностей и пожеланий.
- **Соответствие бюджету и срокам.** Оценить:
    - количество ресурсов, которое потребовалось на реализацию прототипа (время, деньги);
    - объем доработок, которые нужно произвести после внутреннего тестирования и сбора обратной связи;
    - количество ресурсов, которое потенциально потребуется на доработку.